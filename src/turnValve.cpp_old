#include <mar_robot_arm5e/ARM5Arm.h>
#include <visp/vpColVector.h>
#include <visp/vpHomogeneousMatrix.h>
#include <tf/tfMessage.h>
#include <mar_perception/VirtualImage.h>
#include <visp/vpDisplayX.h>



#define GRIPPER_CLOSED -1.2
#define GRIPPER_MANIPULATION -0.6
#define GRIPPER_OPENED 0

#define CURRENTTHRESHOLD 1.0

vpHomogeneousMatrix bMt, bMc;
double roll, pitch, yaw;
bool tf_init=false;
bool arm_to_cam = false;

void tfCallBack(const tf::tfMessage& m){
	KDL::Rotation cKRt;

	vpHomogeneousMatrix cMv;
	bool cam_to_valve = false;

	for (uint i=0; i<m.transforms.size(); i++)
	{
		if (m.transforms[i].header.frame_id == "/base_link" && m.transforms[i].child_frame_id == "/stereo_forward_optical" && !arm_to_cam)
		{
			// Arm to camera
			cKRt=KDL::Rotation::Quaternion(m.transforms[i].transform.rotation.x,m.transforms[i].transform.rotation.y,m.transforms[i].transform.rotation.z,m.transforms[i].transform.rotation.w);
			cKRt.GetRPY(roll, pitch, yaw);
			vpRotationMatrix cRt;
			memcpy(cRt.data, cKRt.data,9*sizeof(double));
			vpTranslationVector cTt(m.transforms[i].transform.translation.x, m.transforms[i].transform.translation.y, m.transforms[i].transform.translation.z);
			bMc.buildFrom(cTt, cRt);
			arm_to_cam = true;
			ROS_INFO("ARM TO CAMERA");
		}
		if (m.transforms[i].header.frame_id == "/stereo_forward_optical" && m.transforms[i].child_frame_id == "/valve")
		{
			// Camera to valve
			cKRt=KDL::Rotation::Quaternion(m.transforms[i].transform.rotation.x,m.transforms[i].transform.rotation.y,m.transforms[i].transform.rotation.z,m.transforms[i].transform.rotation.w);
			cKRt.GetRPY(roll, pitch, yaw);
			vpRotationMatrix cRt;
			memcpy(cRt.data, cKRt.data,9*sizeof(double));
			vpTranslationVector cTt(m.transforms[i].transform.translation.x, m.transforms[i].transform.translation.y, m.transforms[i].transform.translation.z);
			cMv.buildFrom(cTt, cRt);
			cam_to_valve = true;
			ROS_INFO("CAMERA TO VALVE");
		}
	}

	if (cam_to_valve && arm_to_cam)
	{
		bMt = bMc * cMv;
		tf_init=true;
		ROS_INFO("DONE!");
		std::cout<<"bMt Matrix: "<<bMt<<std::endl;
	}

	/*
	cKRt=KDL::Rotation::Quaternion(m.transforms.data()->transform.rotation.x,m.transforms.data()->transform.rotation.y,m.transforms.data()->transform.rotation.z,m.transforms.data()->transform.rotation.w);
	cKRt.GetRPY(roll, pitch, yaw);
	vpRotationMatrix cRt;
	memcpy(cRt.data, cKRt.data,9*sizeof(double));
	vpTranslationVector cTt(m.transforms.data()->transform.translation.x, m.transforms.data()->transform.translation.y, m.transforms.data()->transform.translation.z);
	cMt.buildFrom(cTt, cRt);
	std::cout<<"Matrix tf: "<<cMt<<std::endl;
	tf_init=true;
	*/
}





int main(int argc, char **argv){
	ros::init(argc, argv, "turnValve");
	ros::NodeHandle nh;

	//get Params
	std::string joint_state("");
	nh.getParam("joint_state", joint_state);
	std::string joint_state_command("");
	nh.getParam("joint_state_command", joint_state_command);
	std::string topic_tf("");
	nh.getParam("topic_tf", topic_tf);

	ARM5Arm robot(nh, joint_state, joint_state_command);
	ros::Subscriber tf=nh.subscribe("/tf",1,tfCallBack);
	//VirtualImagePtr grabber(new VirtualImage(nh,"/stereo_down/left/image_raw","/stereo_down/left/camera_info"));
	//while (!grabber->ready()) {
		//	ros::spinOnce();
		//	usleep(10000);
		//}



	//waiting for the valve frame
	while(!tf_init && ros::ok()){
			ros::spinOnce();
			usleep(10000);
		}



	vpHomogeneousMatrix eMh(0,0,0,0,0,0);
	robot.set_eMh(eMh);
	//vpHomogeneousMatrix bMc(-0.18, 0.06, -0.01, 0, 0, 0), auxRotZ(0,0,0,0,0,-1.57), auxRotX(0,0,0,0.2,0,0);
	//bMc=bMc*auxRotZ*auxRotX;
	//vpHomogeneousMatrix bMc(0,0,0,0,0,0);

	vpHomogeneousMatrix oMo(0,0,-0.2,0,0,0), oMo2(-0.0,0,0,0,0,0);



	vpHomogeneousMatrix last_bMt, bMt_prev;
	vpColVector q(5);
	vpColVector q_aux;
	q=0;
	vpHomogeneousMatrix pose_bMt;

	//waiting for a valid position
	do{
		ros::spinOnce();
		bMt_prev=bMt*oMo;
		pose_bMt[0][3]=bMt_prev[0][3];
		pose_bMt[1][3]=bMt_prev[1][3];
		pose_bMt[2][3]=bMt_prev[2][3];
		std::cout<<"pose: "<<pose_bMt<<std::endl;
		q_aux=robot.armIK(pose_bMt);
		std::cout<<q_aux<<std::endl;
	}while(!(q_aux[0]>-1.57 && q_aux[0]<2.1195 && q_aux[1]>0 && q_aux[1]<1.58665 && q_aux[2]>0 && q_aux[2]<2.15294) && ros::ok());
	q[0]=q_aux[0];
	q[1]=q_aux[1];
	q[2]=q_aux[2];
	last_bMt=bMt*oMo.inverse();
	std::cout<<"bMt: "<<bMt<<std::endl;
	std::cout<<"q: "<<q<<std::endl;

return 0;
/*
	//reach the pre-manipulation position
	vpColVector current_joints;
	robot.getJointValues(current_joints);
	q[3]=0;
	q[4]=GRIPPER_OPENED;
	while((q-current_joints).euclideanNorm()>0.05 && ros::ok()){
		ros::spinOnce();
		bMt=bMc*cMt*eMh.inverse()*oMo;
		q_aux=robot.armIK(bMt);
		std::cout<<"Joint Values: "<<q_aux<<std::endl;
		if(q_aux[0]>-1.57 && q_aux[0]<2.1195 && q_aux[1]>0 && q_aux[1]<1.58665 && q_aux[2]>0 && q_aux[2]<2.15294){
			q[0]=q_aux[0];
			q[1]=q_aux[1];
			q[2]=q_aux[2];
			last_bMt=bMt*oMo.inverse();
			std::cout<<"entro en q"<<std::endl;
		}
		robot.getJointValues(current_joints);
		std::cout<<"Current_joints: "<<current_joints<<std::endl;
		robot.setJointVelocity(q-current_joints);
		std::cout<<"velocity: "<<q-current_joints<<std::endl;

	}
    //Put jaw in the correct orientation
	KDL::Rotation bRt_kdl;
	vpRotationMatrix bRt;
	last_bMt.extract(bRt);
	memcpy(bRt_kdl.data,bRt.data,9*sizeof(double));
	double roll, pitch, yaw;
	bRt_kdl.GetRPY(roll, pitch, yaw);
	std::cout<<"giro: "<<roll<<"----"<<pitch<<"----"<<yaw<<std::endl;
	robot.getJointValues(current_joints);
	q[0]=current_joints[0];
	q[1]=current_joints[1];
	q[2]=current_joints[2];
	//q[3]=-pitch;
	q[3]=0;
	q[4]=GRIPPER_OPENED;
	while((q-current_joints).euclideanNorm()>0.05 && ros::ok()){
		ros::spinOnce();
		robot.setJointVelocity(q-current_joints);
		robot.getJointValues(current_joints);
	}
	
	//reach the manipulation position
	std::cout<<"Try to reach the manipulation position"<<std::endl;
	vpHomogeneousMatrix finalFrame=last_bMt*oMo2;
	std::cout<<"last_bMt "<<last_bMt<<std::endl;
	std::cout<<"finalFrame "<<finalFrame<<std::endl;
	q_aux=robot.armIK(finalFrame);
	std::cout<<"armIk "<<q_aux<<std::endl;
	q[0]=fmod(q_aux[0],6.28);
	q[1]=q_aux[1];
	q[2]=q_aux[2];
	//q[3]=-pitch;
	q[3]=0;
	q[4]=GRIPPER_MANIPULATION;
	robot.getJointValues(current_joints);
	while((q-current_joints).euclideanNorm()>0.05 && ros::ok()){
		robot.setJointVelocity((q-current_joints));
		ros::spinOnce();
		robot.getJointValues(current_joints);
	}
	robot.getJointValues(current_joints);
	std::cout<<"Manipulation position reached"<<std::endl;
	q[0]=current_joints[0];
	q[1]=current_joints[1];
	q[2]=current_joints[2];
	q[4]=current_joints[4];
	q[3]=-1.57;
	//Close/Open the valve
	while((q-current_joints).euclideanNorm()>0.05 && ros::ok() && robot.getCurrent()<CURRENTTHRESHOLD){
		vpColVector vel(5);
		vel=0;
		vel[3]=0.7;
		robot.setJointVelocity(vel);
		ros::spinOnce();
		robot.getJointValues(current_joints);
		}
	vpHomogeneousMatrix outFrame=last_bMt*oMo;
	q_aux=robot.armIK(outFrame);
	q[0]=q_aux[0];
	q[1]=q_aux[1];
	q[2]=q_aux[2];
	q[3]=current_joints[3];
	q[4]=GRIPPER_OPENED;
	robot.getJointValues(current_joints);
	//reach the pre-manipulation position
	while((q-current_joints).euclideanNorm()>0.05 && ros::ok()){
			robot.setJointVelocity((q-current_joints));
			ros::spinOnce();
			robot.getJointValues(current_joints);
		}



	//ir lejos
	q[0]=-0.696189;
	q[1]=0.088;
	q[2]=1.15;
	q[3]=current_joints[3];
	q[4]=current_joints[4];
	while((q-current_joints).euclideanNorm()>0.05 && ros::ok()){
		robot.setJointVelocity((q-current_joints));
		ros::spinOnce();
		robot.getJointValues(current_joints);
	}
	return 0;*/


}
