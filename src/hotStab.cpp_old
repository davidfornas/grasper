#include <mar_robot_arm5e/ARM5Arm.h>
#include <visp/vpColVector.h>
#include <visp/vpHomogeneousMatrix.h>
#include <tf/tfMessage.h>



#define GRIPPER_CLOSED -1.28
#define GRIPPER_OPENED 0
#define CURRENT_THRESHOLD 1.0

bool positionValid(vpColVector &joints){
	return true;
	std::cout<<joints<<std::endl;
	if (joints[0]>-1.57 && joints[0]<2.1195 && joints[1]>0 && joints[1]<1.58665 && joints[2]>0 && joints[2]<2.15294){
		return true;
	}
	return false;

}


vpHomogeneousMatrix cMt;
double roll, pitch, yaw;
bool tf_init=false;

void tfCallBack(const tf::tfMessage& m){
	KDL::Rotation cKRt;
	cKRt=KDL::Rotation::Quaternion(m.transforms.data()->transform.rotation.x, m.transforms.data()->transform.rotation.y, m.transforms.data()->transform.rotation.z, m.transforms.data()->transform.rotation.w);

	cKRt.GetRPY(roll, pitch, yaw);
	vpRotationMatrix cRt;
	memcpy(cRt.data, cKRt.data, 9*sizeof(double));
	vpTranslationVector cTt(m.transforms.data()->transform.translation.x, m.transforms.data()->transform.translation.y, m.transforms.data()->transform.translation.z);
	cMt.buildFrom(cTt,cRt);
	tf_init=true;
}


int main(int argc, char **argv){
	ros::init(argc, argv, "hotStab");
	ros::NodeHandle nh;

	//get Params
	std::string joint_state("");
	nh.getParam("joint_state", joint_state);
	std::string joint_state_command("");
	nh.getParam("joint_state_command", joint_state_command);
	std::string topic_tf("");
	nh.getParam("topic_tf", topic_tf);


	ARM5Arm robot(nh, joint_state, joint_state_command);
	ros::Subscriber tf=nh.subscribe(topic_tf, 1, tfCallBack);
	//waiting for the valve frame
	while(!tf_init && ros::ok()){
		ros::spinOnce();
		usleep(10000);
	}

	vpHomogeneousMatrix eMh(0,0,0,0,0,0);
	robot.set_eMh(eMh);
	vpHomogeneousMatrix bMc(0,0,0,0,0,0);
	vpHomogeneousMatrix oMo(-0.05,0,-0.15,0,0,0), oMo2(0.0,0,0,0,0,0), oMo3(-0.05,0,-0.15,0,0,0), oMo4(0.03,0,0.02,0,0,0), oMo5(0.03,0,0.02,0,0,0);//oMo4(0,0,-0.05,0,0,0), oMo5(0.1,0,0.05,0,0,0);


	vpHomogeneousMatrix bMt, last_bMt;
	vpColVector q(5);
	vpColVector q_aux;
	q=0;
	vpHomogeneousMatrix pose_bMt;

	//waiting for a valid position
	do{
		ros::spinOnce();
		bMt=bMc*cMt*eMh.inverse()*oMo;
		pose_bMt[0][3]=bMt[0][3];
		pose_bMt[1][3]=bMt[1][3];
		pose_bMt[2][3]=bMt[2][3];
		std::cout<<"pose: "<<pose_bMt<<std::endl;
		q_aux=robot.armIK(pose_bMt);
		std::cout<<q_aux<<std::endl;
	}while(!(q_aux[0]>-1.57 && q_aux[0]<2.1195 && q_aux[1]>0 && q_aux[1]<1.58665 && q_aux[2]>0 && q_aux[2]<2.15294) && ros::ok());
	q[0]=q_aux[0];
	q[1]=q_aux[1];
	q[2]=q_aux[2];
	last_bMt=bMt*oMo.inverse();
	std::cout<<"bMt: "<<bMt<<std::endl;
	std::cout<<"q: "<<q<<std::endl;

	//reach the pre-manipulation position
		vpColVector current_joints;
		do{
			robot.getJointValues(current_joints);
		}while(!positionValid(current_joints));
		q[3]=0;
		q[4]=GRIPPER_OPENED;
	std::cout<<"Reach the pre-manipulation position"<<std::endl;
		while((q-current_joints).euclideanNorm()>0.05 && ros::ok()){
			ros::spinOnce();
			bMt=bMc*cMt*eMh.inverse()*oMo;
			q_aux=robot.armIK(bMt);
			if(q_aux[0]>-1.57 && q_aux[0]<2.1195 && q_aux[1]>0 && q_aux[1]<1.58665 && q_aux[2]>0 && q_aux[2]<2.15294){
				q[0]=q_aux[0];
				q[1]=q_aux[1];
				q[2]=q_aux[2];
				last_bMt=bMt*oMo.inverse();
			}
			do{
			robot.getJointValues(current_joints);
			}while(!positionValid(current_joints));
			robot.setJointVelocity(q-current_joints);
		}
	    //Put jaw in the correct orientation
		KDL::Rotation bRt_kdl;
		vpRotationMatrix bRt;
		last_bMt.extract(bRt);
		memcpy(bRt_kdl.data,bRt.data,9*sizeof(double));
		double roll, pitch, yaw;
		bRt_kdl.GetRPY(roll, pitch, yaw);
		std::cout<<"giro: "<<roll<<"----"<<pitch<<"----"<<yaw<<std::endl;
		do{
		robot.getJointValues(current_joints);
		}while(!positionValid(current_joints));
		q[0]=current_joints[0];
		q[1]=current_joints[1];
		q[2]=current_joints[2];
		q[3]=0;//-pitch;
		q[4]=GRIPPER_OPENED;
		while((q-current_joints).euclideanNorm()>0.05 && ros::ok()){
			ros::spinOnce();
			robot.setJointVelocity(q-current_joints);
			do{
			robot.getJointValues(current_joints);
			}while(!positionValid(current_joints));
		}
		std::cout<<"reach the manipulation position"<<std::endl;
		//reach the manipulation position
		vpHomogeneousMatrix finalFrame=last_bMt*oMo2;
		std::cout<<"last_bMt "<<last_bMt<<std::endl;
		std::cout<<"finalFrame "<<finalFrame<<std::endl;
		q_aux=robot.armIK(finalFrame);
		std::cout<<"armIk "<<q_aux<<std::endl;
		q[0]=fmod(q_aux[0],6.28);
		q[1]=q_aux[1];
		q[2]=q_aux[2];
		q[3]=0;//-pitch;
		q[4]=GRIPPER_OPENED;
		do{
		robot.getJointValues(current_joints);
		}while(!positionValid(current_joints));
		while((q-current_joints).euclideanNorm()>0.03 && ros::ok()){
			robot.setJointVelocity((q-current_joints));
			ros::spinOnce();
			robot.getJointValues(current_joints);
		}


		//close the gripper
std::cout<<"close the gripper"<<std::endl;
		do{
		robot.getJointValues(current_joints);
		}while(!positionValid(current_joints));
		q[0]=current_joints[0];
		q[1]=current_joints[1];
		q[2]=current_joints[2];
		q[3]=current_joints[3];
		q[4]=GRIPPER_CLOSED;

		while((q-current_joints).euclideanNorm()>0.05 && ros::ok() && robot.getCurrent()<CURRENT_THRESHOLD){
			vpColVector vel(5);
			vel[4]=-0.3;
			robot.setJointVelocity(vel);
			ros::spinOnce();
			do{
			robot.getJointValues(current_joints);
			}while(!positionValid(current_joints));
		}
		std::cout<<"Joint 4: "<<current_joints[4]<<std::endl;
		std::cout<<"unplug the hot-stab"<<std::endl;
		//unplug the hot-stab
		vpHomogeneousMatrix unplugFrame=last_bMt*oMo3;
		q_aux=robot.armIK(unplugFrame);
		//q_aux=robot.armHotStabIK(unplugFrame);
		q[0]=fmod(q_aux[0],6.28);
		q[1]=q_aux[1];
		q[2]=q_aux[2];
		q[3]=current_joints[3];
		q[4]=current_joints[4];
		while((q-current_joints).euclideanNorm()>0.05 && ros::ok()){
			robot.setJointVelocity((q-current_joints));
			ros::spinOnce();
			do{
			robot.getJointValues(current_joints);
			}while(!positionValid(current_joints));
		}


////////Ir lejos


		//unplug the hot-stab
		 unplugFrame=last_bMt*oMo3;
		q_aux=robot.armIK(unplugFrame);
		//q_aux=robot.armHotStabIK(unplugFrame);
		q[0]=-0.696189;
		q[1]=0.088;
		q[2]=1.15;
		q[3]=current_joints[3];
		q[4]=current_joints[4];
		while((q-current_joints).euclideanNorm()>0.05 && ros::ok()){
			robot.setJointVelocity((q-current_joints));
			ros::spinOnce();
			do{
			robot.getJointValues(current_joints);
			}while(!positionValid(current_joints));
		}
std::cout<<"unplug the hot-stab"<<std::endl;
		//unplug the hot-stab
		unplugFrame=last_bMt*oMo3;
		q_aux=robot.armIK(unplugFrame);
		//q_aux=robot.armHotStabIK(unplugFrame);
		q[0]=fmod(q_aux[0],6.28);
		q[1]=q_aux[1];
		q[2]=q_aux[2];
		q[3]=current_joints[3];
		q[4]=current_joints[4];
		while((q-current_joints).euclideanNorm()>0.05 && ros::ok()){
			robot.setJointVelocity((q-current_joints));
			ros::spinOnce();
			do{
			robot.getJointValues(current_joints);
			}while(!positionValid(current_joints));
		}







///////////////////////////
		std::cout<<"preplub hot-stab"<<std::endl;
		//reach pre-plug hot-stab position
		vpHomogeneousMatrix prePlugFrame=last_bMt*oMo4;
		q_aux=robot.armIK(prePlugFrame);
		//q_aux=robot.armHotStabIK(prePlugFrame);
		q[0]=fmod(q_aux[0],6.28);
		q[1]=q_aux[1];
		q[2]=q_aux[2];
		q[3]=current_joints[3];
		q[4]=current_joints[4];
		while((q-current_joints).euclideanNorm()>0.05 && ros::ok()){
			robot.setJointVelocity((q-current_joints));
			ros::spinOnce();
			do{
			robot.getJointValues(current_joints);
			}while(!positionValid(current_joints));
		}
		std::cout<<"open gripper"<<std::endl;
		/*//open the gripper
		robot.getJointValues(current_joints);
		q[0]=current_joints[0];
		q[1]=current_joints[1];
		q[2]=current_joints[2];
		q[3]=current_joints[3];
		q[4]=GRIPPER_OPENED;

		while((q-current_joints).euclideanNorm()>0.05 && ros::ok() && robot.getCurrent()<CURRENT_THRESHOLD){
			vpColVector vel(5);
			vel[4]=0.3;
			robot.setJointVelocity(vel);
			ros::spinOnce();
			robot.getJointValues(current_joints);
		}*/
		std::cout<<"plug the hot-stab"<<std::endl;
		//plug hot-stab
		do{
		robot.getJointValues(current_joints);
		}while(!positionValid(current_joints));
		vpHomogeneousMatrix plugFrame=last_bMt*oMo5;
		q_aux=robot.armIK(plugFrame);
		//q_aux=robot.armHotStabIK(plugFrame);
		q[0]=fmod(q_aux[0],6.28);
		q[1]=q_aux[1];
		q[2]=q_aux[2];
		q[3]=current_joints[3];
		q[4]=current_joints[4];
		while((q-current_joints).euclideanNorm()>0.02 && ros::ok()){
			robot.setJointVelocity((q-current_joints));
			ros::spinOnce();
			robot.getJointValues(current_joints);
		}
		

		//open the gripper
		do{
		robot.getJointValues(current_joints);
		}while(!positionValid(current_joints));
		q[0]=current_joints[0];
		q[1]=current_joints[1];
		q[2]=current_joints[2];
		q[3]=current_joints[3];
		q[4]=GRIPPER_OPENED;

		while((q-current_joints).euclideanNorm()>0.05 && ros::ok() && robot.getCurrent()<CURRENT_THRESHOLD){
			vpColVector vel(5);
			vel[4]=0.3;
			robot.setJointVelocity(vel);
			ros::spinOnce();
			do{
			robot.getJointValues(current_joints);
			}while(!positionValid(current_joints));
		}
		//Finish intervention
		//reach the pre-manipulation position
		vpHomogeneousMatrix finishFrame=last_bMt*oMo;
		do{
		robot.getJointValues(current_joints);
		}while(!positionValid(current_joints));
		q_aux=robot.armIK(finishFrame);
		q[0]=q_aux[0];
		q[1]=q_aux[1];
		q[2]=q_aux[2];
		q[3]=current_joints[3];
		q[4]=GRIPPER_OPENED;


		while((q-current_joints).euclideanNorm()>0.05 && ros::ok()){
			robot.setJointVelocity((q-current_joints));
			ros::spinOnce();
			do{
			robot.getJointValues(current_joints);
			}while(!positionValid(current_joints));
		}


		//ir lejos
		unplugFrame=last_bMt*oMo3;
		q_aux=robot.armIK(unplugFrame);
		//q_aux=robot.armHotStabIK(unplugFrame);
		q[0]=-0.696189;
		q[1]=0.088;
		q[2]=1.15;
		q[3]=current_joints[3];
		q[4]=current_joints[4];
		while((q-current_joints).euclideanNorm()>0.05 && ros::ok()){
			robot.setJointVelocity((q-current_joints));
			ros::spinOnce();
			do{
			robot.getJointValues(current_joints);
			}while(!positionValid(current_joints));
		}


	return 0;
}
